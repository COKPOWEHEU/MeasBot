x.y.z. mygui_gtk
Данный модуль разработан для реализации оконного интерфейса и взаимодействия с пользователем. Он позволяет создавать стандартные элементы управления, такие как кнопки, поля ввода, переключатели, и обрабатывать реакцию на их использование. В качестве основы данного модуля была выбрана распространенная библиотека gtk-3. Она написана на языке Си и является кроссплатформенной.
Современный принцип построения графических интерфейсов подразумевает использование древовидной иерархии вложенности, то есть каждый компонент (кроме окна) принадлежит другому компоненту и может включать в себя дочерние компоненты. Однако для упрощения разработки скриптов пользователями системы автоматизации было решено не переносить эту модель напрямую, позволив вместо этого пользователю использовать компоненты независимо.
Реализация этого принципа в описываемом модуле выглядит следующим образом: подключение самого модуля осуществляется стандартной функцией require("mygui_gtk"), которая создает таблицу gui. Далее методом NewWindow создается одно или больше окон. Каждое из них также представляет собой таблицу и обладает методами создания компонентов. Как и было описано ранее, с точки зрения скрипта эти компоненты являются независимыми и могут группироваться пользователем в произвольные структуры. Однако с точки зрения gtk иерархия остается неизменной. В том случае, если надобность в компоненте отпала, его можно удалить стандартным для Lua способом - присвоить ему nil. Как только переменных, связанных с компонентом, не останется, он будет очищен сборщиком мусора.
Обработка оконных событий (перемещение, изменение размера, нажатие на кнопки т т.д.) осуществляется в gtk периодическим вызовом gtk_main_iteration_do(0). Хорошим решением было бы вынести его в отдельный поток чтобы скорость работы интерфейса не была привязана к интерпретатору скрипта, но учитывая, что Lua для многопоточной работы не предназначена, было принято решение не переусложнять прогрмму без необходимости и оставить ручной вызов метода update(). Результатом этого является зависимость отклика интерфейса от работы других модулей и логики скрипта, что в некоторых случаях может быть некомфортным.
Обработка событий может заключаться как в пассивном изменении состояния (например, текста в поле ввода), так и в вызове соответствующего метода (callback). Доступные поля и callback'и описаны ниже в таблице ???.
Расположение элементов управления в настоящий момент задается явным указанием координат относительно левого верхнего угла родительского компонента. Строго говоря, это не лучший способ, поскольку не позволяет простым способом менять расположение компонентов при изменении размеров окна, как табличная верстка, но он был признан более простым для не-программистов. Кроме того, большая часть утилит автоматизации пишется "для себя", то есть предполагает в первую очередь простоту и функциональность, а не гибкость и дизайн. К тому же они пишутся под конкретный набор приборов и конкретный алгоритм проведения эксперимента, то есть при их изменении программу придется менять в любом случае, так что простота расположения компонентов заново оказывается важнее адаптации к широкому диапазону условий.

Независимость представлений gtk и Lua приводит к необходимости поддерживать синхронизацию двух независимых наборов объектов. Для этого используется с одной стороны глобальный объект языка Си (что могло бы вызвать проблемы при попытке создания нескольких объектов этого типа, но вследствие специфики задачи они могут быть проигнорированы), с другой - глобальный объект Lua, создаваемый при инициализации (он не имеет имени, только номер в реестре, хранящийся в переменной gui.poolidx) и с третьей - локальная таблица, создаваемая функцией require("mygui_gtk"). Как и другие объекты, представленные таблицами, эта содержит метатаблицу, предназначенную для обработки высокоуровневых методов. Список визуальных компонентов также было решено хранить в виде поля этой таблицы под названием pool. Побочным эффектом является то, что на любой созданный компонент появляется минимум две ссылки - возвращаемая функцией создания и элемент пула компонентов в метатаблице. Это мешает сборщику мусора определить когда пользователь удаляет последнюю ссылку, доступную ему. Одним из способов решения этой проблемы являются "мягкие" ссылки, то есть те, которые не учитываются сборщиком мусора. Они настраиваются равенством поля __mode в метатаблице строке 'v'.

Создание нового элемента управления совмещено с прстроением иерархии и осуществляется вызовом метода соответствующего контейнера. В настоящий момент реализованы контейнеры Window, Frame и TabControl, причем Window может быть только корневым контейнером, то есть создается только из объекта gui, остальные два создаются методами NewFrame и NewTabControl соответственно. Стоит отметить, что при удалении объекта контейнера все вложенные в него компоненты также будут удалены. Однако это относится только к объектам gtk и самого контейнера. То есть если переменная Lua не была полем контейнера, она удалена не будет, а доступ к ней приведет к ошибке.
Для всех компонентов характерно наличие полей x, y, width, height, которые соответствуют положению и размеру компонента относительно контейнера.

Использование большинства остальных элементов управления особых пояснений не требует. За исключением компонента plot (рисование графиков), про который стоит рассказать отдельно.
Данные для отображения хранятся в виде поля data, изменять которое он не может (то есть это поле может быть просто ссылкой на существующую таблицу), представляющего собой массив векторов, то есть каждый элемент поля data также является таблицей со своими полями. По сути эта таблица хранит все значения данной точки. Например, для эксперимента по измерению эффекта Холла это могут быть напряженность внешнего поля, ток через образец, измеренное холловское напряженние и рассчитанный эффект Холла. То есть четыре элемента. Однако отображать их все на одном графике бессмысленно, поскольку единицы измерения отличаются. Поэтому в компонент plot было добавлено поле format, отвечающее за то, какие именно поля "точек" будут отображены. Поле format.x (или format[0]) задает номер элемента, соответствующий X-координате (нумерация начинается с 1, отсутствие поля или его равенство минус единице означает отсутствие в "точке" X-координаты, вследствие чего развертка будет линейной, то есть X-координата первой точки будет 1, второй - 2 и т.д.). Остальные поля этой таблицы задают номера индексов кривых. Например, запись format = {x=2, 4, 1} означает что x-координата это 2-й элемент данных, первая кривая рисуется по 4-му элементу, а вторая кривая - по 1-му.
Масштаб графика выбирается автоматически и из скрипта изменен быть не может. Для оценки величины сигнала в процессе измерения удобным является наличие курсора и вывод значений графика, ему соответствующих. Для этого служит поле cur_size, которое задает размер курсора как долю от размера компонента plot. То есть при cur_size = 1 ширина и высота перекрестья равны ширине и высоте графика соответственно. Для того, чтобы перекрестье всегда занимало всю видимую область следует ставить cur_size>=2. Также таблица plot содержит поля cur_x, cur_y, в которых хранятся текущие значения координат курсора например для вывода на какой-то другой компонент.
Поскольку поле data строго говоря компоненту plot не принадлежит, он не может определить когда в него добавляются новые данные. Поэтому обновление графика вынескно в метод Refresh, который нужно вызывать из скрипта.
Вследствие значительного числа компонентов, описание их взаимодействия заняло бы слишком много места и не было бы достаточно информативным. Вместо этого в файле data/script.lua находится пример использования данного модуля.

Window
поля:
enabled - разрешено ли взаимодействие с контейнером и элементами в нем
resizable - разрешено ли изменение размеров окна
visible - видимость окна
методы:
New{component} - создание компонента
Show() - отобразить окно
Hide() - спрятать окно
события (callback):
OnShow(), OnHide() - действия при изменении видимости окна

Контейнеры (Frame, TabControl)
поля:
x, y, width, height - положение и геометрия компонента
enabled - разрешено ли взаимодействие с контейнером и элементами в нем
label (у Frame) - видимое пользователю название контейнера
tab (у TabControl) - массив вкладок. Создание новой вкладки осуществляется присвоением ее имени соответствующему элементу. После этого вкладка становится полноценным контейнером с возможностью создания компонентов. Специальное поле text позволяет изменить имя вкладки на лету.
методы:
New{component} - создание компонента

Текстовая метка Label
поля:
x,y - положение в контейнере
text / label (два имени одной переменной) - отображаемый текст

Кнопка Button
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
методы:
WasClicked() - была ли нажата кнопка с момента предыдущего вызова этого метода (несовместимо с событием OnClick)
события (callback):
OnClick() - событие по нажатию

Поле текстового ввода Edit
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
text - введенный текст
события (callback):
OnEnter(text) - событие при окончании ввода пользователем текста. Введенный текст передается в качестве аргумента.

Поле графика Plot
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
cur_size - размер курсора (если отрицательное, курсор не отображается)
cur_x, cur_y - координаты курсора
data - данные для графика
format - используемые столбцы и их назначение (см. выше)
методы:
Refresh() - перерисовать график

Флажки ToggleButton, CheckBox, SwitchButton
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
checked - поставлен ли флажок
события (callback):
[OnChange] - планируется добавить событие изменения состояния

Кнопка выбора из вариантов RadioButton
Отличается от предыдущих кнопок тем, что могут быть объединены в группу, в которой нажата только одна кнопка. Соответствено, при создании можно указать любую другую RadioButton, к группе которой будет добавлена создаваемая
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
selected - выбрана ли именно эта кнопка
методы:
Reattach() - указать другую группу (по входящей в нее кнопке)
GetSelected() - получить объект нажатой кнопки
события (callback):
[OnChange] - планируется добавить событие изменения состояния

Выпадающий список ComboBox
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
selected - номер выбранного элемента
методы:
SelectedItem() - получить текст выбранного пункта
SetItems, GetItems - задать или получить список элементов для выбора (массв строк)
события (callback):
OnChange - событие изменения состояния

Поле числового ввода SpinEdit
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
min, max - минимальное и максимальное значения
val / value - текущее значение
step - шаг изменения при нажатии на кнопки увеличения и уменьшения
digits - количество десятичных цифр, отображаемых полем
события (callback):
OnChange - событие изменения состояния

Полоа прокрутки Scroller
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
min, max - минимальное и максимальное значения
value - текущее значение
step - шаг изменения при нажатии на кнопки увеличения и уменьшения
show_val - показывать ли числовое значение рядом с ползунком
события (callback):
OnChange - событие изменения состояния

Полоса прогресса ProgressBar
поля:
x, y, width, height - положение и геометрия компонента
enabled - доступность для взаимодействия
min, max - минимальное и максимальное значения
val / value - текущее значение
frac / fraction - процент заполнения (то же, что val / value, но в процентах. Взаимосвязан с ним)

Диалоги SaveFileDialog, OpenFileDialog, PathDialog, QuestionDialog, MessageDialog
По сути, это не объекты, а функции. Вызывается окно диалога выбора сохранения файла, открытия файла (отличается от предыдущего тем, что файл обязан существовать), выбора пути (открывается не файл, а каталог), после нажатия ОК или Отмера в котором в скрипт возвращается строка с путем до файла или каталога.
QuestionDialog - диалог выбоа OK/Отмера. Возвращается логическое значение
MessageDialog - диалог вывода информации. Не возвращает ничего
